---
import { z } from 'zod';
import type { Agent } from '../agents/featureSetSchema';
import { featuresRegistry, subfeaturesRegistry, featureSetSchema } from '../agents/featureSetSchema';
import CategoryRow from './CategoryRow.astro';

interface Props {
  agents: Agent[];
}

const { agents } = Astro.props;

// Extract display names from registry
function formatDisplayName(key: string): string {
  return key
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// Build category display names from registry
const categoryDisplayNames: Record<string, string> = {};
const featureDisplayNames: Record<string, string> = {};

const categoryOrderEnum = featureSetSchema.keyof().enum;
const categoryOrder = Object.values(categoryOrderEnum) as (keyof typeof categoryOrderEnum)[];
for (const categoryKey of categoryOrder) {
  const categorySchema = featureSetSchema.shape[categoryKey];
  const categoryMeta = featuresRegistry.get(categorySchema);
  if (!categoryMeta) {
    throw new Error(`Category ${categoryKey} not found in featuresRegistry`);
  }
  categoryDisplayNames[categoryKey] = categoryMeta.name 
    ? formatDisplayName(categoryMeta.name) 
    : formatDisplayName(categoryKey);
  
  // Extract feature names from each category
  // categorySchema is a union type (FeatureStatus | ZodObject), so we need to check
  if (categorySchema instanceof z.ZodUnion) {
    // Find the object option in the union
    const objectOption = categorySchema.options.find(opt => opt instanceof z.ZodObject);
    if (objectOption instanceof z.ZodObject) {
      const featureKeys = Object.keys(objectOption.shape);
      for (const featureKey of featureKeys) {
        const featureSchema = (objectOption.shape as Record<string, z.ZodType>)[featureKey];
        const subfeatureMeta = subfeaturesRegistry.get(featureSchema);
        featureDisplayNames[featureKey] = subfeatureMeta?.name 
          ? formatDisplayName(subfeatureMeta.name) 
          : formatDisplayName(featureKey);
      }
    }
  } else if (categorySchema instanceof z.ZodObject) {
    // Fallback for direct ZodObject (shouldn't happen with new schema, but keep for safety)
    const featureKeys = Object.keys(categorySchema.shape);
    for (const featureKey of featureKeys) {
      const featureSchema = (categorySchema.shape as Record<string, z.ZodType>)[featureKey];
      const subfeatureMeta = subfeaturesRegistry.get(featureSchema);
      featureDisplayNames[featureKey] = subfeatureMeta?.name 
        ? formatDisplayName(subfeatureMeta.name) 
        : formatDisplayName(featureKey);
    }
  }
}

// Define feature order
const featureOrder: Record<string, string[]> = {
  planMode: ['dual-model'],
  documentation: ['filesystem', 'tree', 'multi-file', 'llms-txt', 'auto-merge', 'partial'],
  reasoning: ['explanation-in-natural-language', 'step-by-step-view'],
  tools: ['search-engine', 'fetch-data'],
};
---

<div class="table-card">
  <table>
    <thead>
      <tr>
        <th class="feature-col">Feature</th>
        {agents.map((agent) => (
          <th class="agent-col">{agent.meta.name}</th>
        ))}
      </tr>
    </thead>
    <tbody>
      {categoryOrder.map((categoryKey: keyof Agent['features']) => {
        const category = categoryKey;
        const categorySchema = featureSetSchema.shape[category];
        const categoryMeta = featuresRegistry.get(categorySchema);
        if (!categoryMeta) {
          throw new Error(`Category ${categoryKey} not found in featuresRegistry`);
        }
        const features = featureOrder[category] || [];
        return (
          <CategoryRow
            categoryKey={category}
            categoryName={categoryDisplayNames[category]}
            features={features}
            agents={agents}
            mainColor={categoryMeta.mainColor}
            secondaryColor={categoryMeta.secondaryColor}
            categorySlug={categoryMeta.slug || category}
            featureDisplayNames={featureDisplayNames}
          />
        );
      })}
    </tbody>
  </table>
</div>

<style>
  /* Table Card */
  .table-card {
    background-color: var(--bg-card);
    border-radius: 16px;
    box-shadow: 
      0 1px 3px rgba(0, 0, 0, 0.04),
      0 4px 12px rgba(0, 0, 0, 0.06);
    overflow: hidden;
    margin-top: 1rem;
  }

  /* Table */
  table {
    width: 100%;
    border-collapse: collapse;
  }

  thead tr {
    border-bottom: 1px solid var(--border-light);
  }

  th {
    padding: 1rem 1.25rem;
    text-align: left;
    font-weight: 500;
    font-size: 0.9rem;
    color: var(--text-secondary);
  }

  th.feature-col {
    width: 280px;
    font-weight: 600;
  }

  th.agent-col {
    text-align: center;
    min-width: 100px;
  }

  /* Table body - borders only between categories */
  tbody tr {
    border-bottom: none;
  }

  /* Add border before category rows (acts as separator between category groups) */
  .category-row {
    border-top: 1px solid var(--border-light);
  }

  /* First category row doesn't need top border */
  tbody tr:first-child.category-row {
    border-top: none;
  }

  /* Last row in table gets bottom border for visual closure */
  tbody tr:last-child {
    border-bottom: none;
  }

  td {
    padding: 0.875rem 1.25rem;
    vertical-align: middle;
  }

  /* Responsive */
  @media (max-width: 900px) {
    .table-card {
      border-radius: 12px;
    }
    
    th, td {
      padding: 0.75rem 0.75rem;
    }
    
    .category-row td {
      padding: 0.9rem 0.75rem;
    }
    
    .feature-row td {
      padding: 0.4rem 0.75rem;
    }
    
    th.feature-col {
      width: 180px;
    }
  }

  @media (max-width: 600px) {
    .table-card {
      overflow-x: auto;
    }
    
    table {
      min-width: 500px;
    }
    
    th.feature-col {
      width: 150px;
    }
    
    .feature-name {
      padding-left: 0.75rem;
    }
    
    .category-row td {
      padding: 0.8rem 0.6rem;
    }
    
    .feature-row td {
      padding: 0.35rem 0.6rem;
    }
  }
</style>
